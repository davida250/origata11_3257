<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Prism Fold — three.js</title>
    <style>
      html,body { height: 100%; margin: 0; background: #000; overflow: hidden; }
      #app { position: fixed; inset: 0; }
      .hint {
        position: fixed; left: 12px; bottom: 12px; color: #a0a0a0; font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: rgba(0,0,0,.4); padding: 8px 10px; border-radius: 6px; user-select: none;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="hint">Drag to orbit • Move mouse to “fold” • Wheel = stripes • <kbd>B</kbd> = bloom • <kbd>R</kbd> = reset</div>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
      import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
      import { ShaderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js';
      import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
      import { RGBShiftShader } from 'https://unpkg.com/three@0.160.0/examples/jsm/shaders/RGBShiftShader.js';

      const app = document.getElementById('app');

      const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 0, 5);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Geometry: start with an icosahedron for crisp facets
      const geo = new THREE.IcosahedronGeometry(1.0, 1);

      const uniforms = {
        uTime: { value: 0 },
        uFold: { value: 0.8 },
        uStripeFreq: { value: 11.0 },
        uStripeMove: { value: 1.25 },
        uThicknessBase: { value: 420.0 }, // nm
        uIorFilm: { value: 1.38 },
        uBaseColor: { value: new THREE.Color(0x0a0f08) },
      };

      const vert = /* glsl */ `#version 300 es
      precision highp float;
      uniform float uTime;
      uniform float uFold;

      in vec3 position;
      in vec3 normal;

      uniform mat4 modelMatrix;
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform mat3 normalMatrix;

      out vec3 vNormal;
      out vec3 vPosView;
      out vec3 vPosWorld;

      void foldPlane(inout vec3 p, inout vec3 nrm, vec3 pn, float d, float k){
        float s = dot(p, pn) + d;
        float m = smoothstep(0.0, 1.0, k * max(-s, 0.0));
        p -= 2.0*m*s*pn;
        nrm = normalize(nrm - 2.0*m*dot(nrm, pn)*pn);
      }

      mat3 rotY(float a){
        float c = cos(a), s = sin(a);
        return mat3(c,0.,s, 0.,1.,0., -s,0.,c);
      }

      void main(){
        vec3 p = position;
        vec3 nrm = normal;

        // gentle rotation for life
        float a = uTime * 0.25;
        mat3 R = rotY(a);
        p = R * p;
        nrm = R * nrm;

        // three animated folding planes
        vec3 p1 = normalize(vec3(0.7, 0.0, 0.7));
        vec3 p2 = normalize(vec3(-0.3, 0.9, 0.1));
        vec3 p3 = normalize(vec3(0.0, 0.7, -0.7));
        float d = 0.22 * sin(uTime * 0.6);

        foldPlane(p, nrm, p1,  d, uFold);
        foldPlane(p, nrm, p2, -d, uFold);
        foldPlane(p, nrm, p3,  d, uFold);

        vec4 mv = modelViewMatrix * vec4(p, 1.0);
        vPosView = mv.xyz;
        vPosWorld = (modelMatrix * vec4(p,1.0)).xyz;
        vNormal = normalize(normalMatrix * nrm);

        gl_Position = projectionMatrix * mv;
      }
      `;

      const frag = /* glsl */ `#version 300 es
      precision highp float;

      uniform float uTime;
      uniform float uStripeFreq;
      uniform float uStripeMove;
      uniform float uThicknessBase;
      uniform float uIorFilm;
      uniform vec3  uBaseColor;

      in vec3 vNormal;
      in vec3 vPosView;
      in vec3 vPosWorld;
      out vec4 outColor;

      const float PI = 3.141592653589793;

      vec3 thinFilmIridescence(float thickness, float n1, float n2, float n3, float cosTheta1){
        // simplified interference term across RGB wavelengths (in nanometers)
        vec3 lambda = vec3(680.0, 550.0, 440.0);
        float sinTheta1 = sqrt(max(0.0, 1.0 - cosTheta1*cosTheta1));
        float sinTheta2 = n1 / n2 * sinTheta1;
        float cosTheta2 = sqrt(max(0.0, 1.0 - sinTheta2*sinTheta2));
        vec3 phase = 4.0 * PI * n2 * thickness * cosTheta2 / lambda;
        // cosine-based interference intensity (approximate)
        return 0.5 + 0.5 * cos(phase);
      }

      void main(){
        vec3 N = normalize(vNormal);
        vec3 V = normalize(-vPosView);
        float NdotV = clamp(dot(N, V), 0.0, 1.0);

        // Stripes in object/world space
        vec3 dir = normalize(vec3(0.7, 0.0, 0.3));
        float coord = dot(vPosWorld, dir) * uStripeFreq + uTime * uStripeMove;
        float s = 0.5 + 0.5 * sin(coord);
        float stripe = smoothstep(0.70, 0.98, s);

        float thickness = uThicknessBase * (0.7 + 0.3 * sin(coord + uTime * 0.5));
        vec3 film = thinFilmIridescence(thickness, 1.0, uIorFilm, 1.0, NdotV);

        // Simple lambert + fresnel
        vec3 L = normalize(vec3(0.4, 0.8, 0.2));
        float diff = max(dot(N, L), 0.0);
        float f0 = 0.06;
        float fresnel = f0 + (1.0 - f0) * pow(1.0 - NdotV, 5.0);

        vec3 color = uBaseColor * diff;
        color = mix(color, film, 0.75);
        color += film * stripe * 1.5;
        color += fresnel * film;
        float rim = pow(1.0 - NdotV, 2.0);
        color += rim * film * 0.2;

        outColor = vec4(color, 1.0);
      }
      `;

      const mat = new THREE.ShaderMaterial({
        uniforms, vertexShader: vert, fragmentShader: frag, glslVersion: THREE.GLSL3,
        side: THREE.DoubleSide, transparent: false
      });

      const mesh = new THREE.Mesh(geo, mat);
      scene.add(mesh);

      // Postprocessing
      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.05, 0.5, 0.15);
      composer.addPass(bloomPass);

      const rgbShift = new ShaderPass(RGBShiftShader);
      rgbShift.uniforms['amount'].value = 0.0015;
      rgbShift.uniforms['angle'].value = Math.PI / 4;
      composer.addPass(rgbShift);

      // Interaction
      let pointerX = 0.5, pointerY = 0.5;
      window.addEventListener('pointermove', (e) => {
        pointerX = e.clientX / window.innerWidth;
        pointerY = e.clientY / window.innerHeight;
        uniforms.uFold.value = THREE.MathUtils.lerp(0.2, 1.2, pointerX);
      });

      window.addEventListener('wheel', (e) => {
        uniforms.uStripeFreq.value = Math.max(2.0, uniforms.uStripeFreq.value + (e.deltaY > 0 ? -0.5 : 0.5));
      }, { passive: true });

      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'b') {
          bloomPass.enabled = !bloomPass.enabled;
        } else if (e.key.toLowerCase() === 'r') {
          uniforms.uStripeFreq.value = 11.0;
          uniforms.uFold.value = 0.8;
        }
      });

      // Resize
      function onResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener('resize', onResize);

      // Animate
      const clock = new THREE.Clock();
      function animate(){
        uniforms.uTime.value = clock.getElapsedTime();
        mesh.rotation.y += 0.002;
        controls.update();
        composer.render();
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
